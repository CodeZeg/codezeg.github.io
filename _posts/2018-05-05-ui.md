---
layout: post
title: ui框架
description: 一套ui框架的基本实现
categories: unity, ugui, ui, lua, framework
---

# UI框架设计
> 项目进入中后期，因发行需求需要将原本无法热更新的外围系统全部改造为可以热更新的版本，这里分析一下现有的ui框架设计以及未来的改造情况。
> 技术选型为 ugui+tolua
> 跟修楼房一样，框架结构的意义是让每个人都只关注自己的工作，按部就班的去实施流水线作业中的一部分，最终就能造出可靠稳定的高楼大厦
## 需求分析
### 框架设计原则与目的
> 需求分析是指整套框架要做什么
1. 明确各部门工作流
1. 细化程序执行工作流
> 指定工作流的原则和依据是什么
1. 简单易执行 `流水线如果过于复杂会导致大量的人力负担`
1. 减少重复劳动 `重复的事情会浪费时间，降低积极性`
1. 功能独立可靠稳定 `工作流要保证各职能互相之间的依赖尽量小，消除相互的等待时间，提升效率`
1. 后续维护 `功能文档的整理，程序文档的整理会降低阅读程序的时间`
### 工作流分析
> 工作流是指整个团队在项目执行过程中的一整套流程
1. 策划设计功能系统方案 `策划案，配置表，ui草图`
1. 美术设计实际UI表现  `效果图,图片，字号，颜色`
1. 策划拼装资源到引擎中 `窗口预制体`
1. 程序编码+联调 `实际可玩的程序功能`
1. 测试进行自动测试+手动测试 `bug`
1. 程序策划修复bug `质量更高的程序功能`
1. 重复上两步 `最终产品`
> 那么各部门工作流该如何科学分配
1. 策划先行 `系统方案是基础，必须等待方案完成才可以正式开工`
1. 美术资源与程序数据层并行 `程序功能中的数据层是不需要美术资源的因此可以并行`
1. 策划拼装ui资源 `ui资源的修改是非常频繁的，功能开发必然是一个多次迭代的过程，那么如果程序拼装ui会导致程序需要同时跟策划和美术频繁沟通效率低下，美术拼装的话会导致美术需要频繁打断自身的创意工作，频繁的在美术编辑器和引擎编辑器下切换，策划如果可以在第一时间修改微调是效率最高的`
1. 程序编码 `客户端和服务器在代码完成后都应该可以自测，减少联调的时间成本`
1. 自动化测试 `项目进入后期，人工测试一轮项目全部功能的耗时会超过8小时，再加上不同的设备之类，时间会更长。而且长期的重复测试会失去耐心，一些曾经测试过的地方可能并不能测试完全。`
### 客户端程序框架分析
1. 数据层 `数据本身有本地配置表和服务器下行数据，附带对数据的操作。`
1. 显示层 `显示层就是一个一个的显示元件窗口预制件等。`
1. 中间层 `中间层的作用是将数据显示到显示层中做一个桥接的作用。`
1. 辅助层 `辅助层的作用是用来帮助以上的三层架构快速自动化生成部分内容。`
1. 支撑层 `提供一些特殊的操作解决方案`
> 数据层与显示层是完全不依赖的，并行工作，程序先写数据层，策划和美术制作显示层。交互之后由程序完成中间层。
#### 数据层的具体实施
> 数据层我这里设计为一个一个的服务，取自web架构中的微服务概念，各个服务之间需要尽量保持无依赖的关系，每个服务对外仅提供一些对数据的增删改查的接口。
> 微服务与功能模块的区别，模块的概念其实是比服务要大的，一个模块的概念应该是一整套的系统功能，而服务表示只是数据层面的操作接口，而不含有具体的操作流程。。
> C#层面的思路和lua这边一致所以这里只会讲到lua这边的实现。
1. 微服务基类 `Service.lua`
基类只提供基本的收发协议的通信接口，并负责打印日志解析protobuf等。
基类还提供一些公共的流水线的虚方法，例如游戏开始，登录成功，登出，退出游戏等。
1. 微服务管理类 `ServiceManager.lua`
管理类的作用是注册各个服务，每一个服务必须要在管理类中注册，流水线才能开动起来。
#### 显示层的具体实施
> 显示层的设计原则是如果可以交给策划，那么就不要交给程序，可以减少不必要的沟通成本。
> 原理是制作一些通用的脚本，策划在制作预制件的时候按照指定的规则和需求添加，原则上太多特殊的脚本是不应该丢给策划的，会增加沟通负担。当然一些特殊的脚本也是可以程序到显示层来操作的。
1. `UIContext.cs` 显示层需要指定需要被中间层操作的组件并注释。
1. `UILayer.cs` 窗口层级管理，例如新手引导一定显示在普通窗口上面。
1. `UIAnimator.cs` 窗口打开、关闭、运行中等动画效果等。
1. `UIGroup.cs` 窗口间的互斥依赖关系，例如从好几个界面可以查看道具信息并以此跳转到商店界面，如果在中间层写代码那么每次添加这样的窗口都需要在道具这里写关闭xxx窗口，耦合性变高，出错率变高。因此我这里通过这个脚本让策划来设计，这一个窗口属于什么类别，这个窗口打开的时候要关闭什么类别的窗口，关闭时又要关闭什么类别的窗口。
1. `UIHideBackWindow.cs` 窗口间的阻挡显示关系，处于性能考虑，例如一个全屏窗口打开的时候，大厅主界面的窗口实际上不需要渲染了，这个时候隐藏掉会比较好。
1. `UIIgnoreEventDelayCall.cs` 窗口打开的时候屏蔽操作。例如打开一个带有动画的界面，如果不屏蔽操作，可能会存在动画弹出过程中的误操作和连续操作，导致bug。
1. `UILocalization.cs` 一些不需要程序处理的本地化语言包处理。例如`邮件`这个标题，策划只需要绑定上对应的语言包id就好，并不需要程序来写代码。
1. `UIPrefab.cs` 一个窗口中如果要嵌套另外一个预制件就需要用到该操作了，例如我们的很多个界面，都会有顶部菜单，用于显示一个关闭按钮和一些货币数量等。
1. `UIWidth.cs` 该脚本涉及到了游戏中显示3D模型的方案，这里因为使用到了透视摄像机，会导致越远的地方两层之间的间隔越大，模型变大，造成3D模型超过了两层之间的距离导致显示异常的bug。所以用该脚本指定这个模型需要两层的空间等。
#### 中间层的具体实施
1. 中间层基类有两个: 视图 `UIView` ，窗口 `UIWindow`
视图的概念是用来表达一个局部的显示控制逻辑，视图可以是一个窗口也可以窗口的一小部分，具体怎么细分应该依据复用情况来。窗口会有窗口的名字，依赖关系等额外的窗口属性。
1. 工作流水线
视图和窗口共享一套流水线过程。
打开窗口: 获取显示层组件 => 添加事件 => 绑定属性 => 窗口打开后的处理。
关闭窗口: 窗口关闭时的处理  => 自动移除绑定属性 => 自动移除事件。
一般的UI框架中还会存在 `Update`，`LateUpdate` 等流程，但本框架中去除了，原因是每个地方都来做计时其实是一种浪费，时间相关的处理会有全局的时间管理器辅助进行。
1. 属性 `XProperty`
属性的概念是参考的`MVP`框架的一个产物，用绑定一个属性到一个方法上，让这个属性变更的时候自动的调用该显示方法。取代过去的，先显示某个值，然后监听一个事件，数据层每次修改值都要去通知这个事件。省却了很多复杂度，降低了出bug的概率。
#### 辅助层的具体实施
1. `Demo场景` 提供了大量的UI组件使用说明示例，可以让策划快速上手制作。
1. `屏幕适配` 制作了工具让策划可以快速查看ui在不同的分辨率下显示结果，后续应该做一个 自动生成所有UI适配结果的工具效率会更高。
1. `代码自动生成` 例如`获取显示层组件`的逻辑，自动生成的代码，既高效又不容易出现大小写错误等问题。
1. `制作流程文档规范等` 制定一些制作规范和一些性能优化的注意事项等文档。
#### 支承层的具体实施
> 支撑层的东西会有很多，并且持续增加，这里只简单介绍两个
1. `虚拟列表` `UIListContainer.cs` UGUI本身并没有提供一个高性能的列表组件，例如一个聊天界面，如果存在一万条聊天记录，那么同时实例化一万个Object是不科学的。
1. `3D显示` 通常UGUI中显示3D模型都会使用`RenderTexture`，但该方案劣势明显，内存较大，显示精度低等。因此我们项目中选用了真3D模式，UI在需要显示3D模型的时候会自动调整为摄像机模式，把UI作为一个空间多层的形式存在。
1. `图文混排` 图文混排也是一个常用的东西。










